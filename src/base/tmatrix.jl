"""
Iterator for the order-degree pairs of the given maximum order `n‚Çò‚Çê‚Çì`.
"""
struct OrderDegreeIterator
    n‚Çò‚Çê‚Çì::Int
end

Base.iterate(::OrderDegreeIterator) = ((1, -1), (1, -1))
function Base.iterate(iter::OrderDegreeIterator, (n, m))
    if m == n
        n == iter.n‚Çò‚Çê‚Çì ? nothing : ((n + 1, -n - 1), (n + 1, -n - 1))
    else
        ((n, m + 1), (n, m + 1))
    end
end

Base.firstindex(iter::OrderDegreeIterator) = 1
Base.lastindex(iter::OrderDegreeIterator) = length(iter)
function Base.getindex(iter::OrderDegreeIterator, idx)
    n = floor(Int, ‚àöidx)
    m = idx - n^2 - n
    (n, m)
end
Base.length(iter::OrderDegreeIterator) = iter.n‚Çò‚Çê‚Çì * (iter.n‚Çò‚Çê‚Çì + 2)
Base.size(x::OrderDegreeIterator) = (length(x),)
Base.eltype(::OrderDegreeIterator) = Tuple{Int, Int}
Base.isdone(iter::OrderDegreeIterator, state) = state >= (iter.n‚Çò‚Çê‚Çì, iter.n‚Çò‚Çê‚Çì)

@testitem "OrderDegreeIterator" begin
    using TransitionMatrices: OrderDegreeIterator

    @test iterate(OrderDegreeIterator(3)) == ((1, -1), (1, -1))
    @test iterate(OrderDegreeIterator(3), (1, 1)) == ((2, -2), (2, -2))
    @test collect(OrderDegreeIterator(2)) ==
          [(1, -1), (1, 0), (1, 1), (2, -2), (2, -1), (2, 0), (2, 1), (2, 2)]
    @test size(OrderDegreeIterator(100)) == (10200,)
    @test !Base.isdone(OrderDegreeIterator(2), (1, 1))
    @test Base.isdone(OrderDegreeIterator(2), (2, 2))
end

@doc raw"""
A general T-Matrix ``T_{m n m^{\prime} n^{\prime}}^{k l}`` stored in a 6-dimensional array, in the order ``(m, n, m^{\prime}, n^{\prime}, k, l)``.
"""
abstract type AbstractTransitionMatrix{CT, N} <: AbstractArray{CT, 6} end

"""
Get the maximum order of a T-Matrix.
"""
order(::AbstractTransitionMatrix{CT, N}) where {CT, N} = N

Base.size(::AbstractTransitionMatrix{CT, N}) where {CT, N} = (2N + 1, N, 2N + 1, N, 2, 2)
function Base.axes(::AbstractTransitionMatrix{CT, N}) where {CT, N}
    ((-N):N, 1:N, (-N):N, 1:N, 1:2, 1:2)
end

"""
Concrete type for a general T-Matrix.
"""
struct TransitionMatrix{CT, N, V <: AbstractArray{CT}} <: AbstractTransitionMatrix{CT, N}
    container::V
end

Base.getindex(tm::TransitionMatrix{CT, N}, idx) where {CT, N} = getindex(tm.container, idx)
function Base.getindex(tm::TransitionMatrix{CT, N}, idxs...) where {CT, N}
    getindex(tm.container, idxs...)
end

@doc raw"""
Rotate the given T-Matrix `ùêì` by the Euler angle `rot` and generate a new T-Matrix.

### General T-Matrix

```
rotate(ùêì::AbstractTransitionMatrix{CT, N}, rot::Rotation{3})
```

For a general T-Matrix, Eq. (5.29) in Mishchenko et al. (2002) is used as a fallback. A `TransitionMatrix` will be returned, which is the most general yet concrete type.

```math
T_{m n m^{\prime} n^{\prime}}^{p p‚Ä≤}(L ; \alpha, \beta, \gamma)=\sum_{m_1=-n}^n \sum_{m_2=-n^{\prime}}^{n^{\prime}} D_{m m_1}^n(\alpha, \beta, \gamma) T_{m_1 n m_2 n^{\prime}}^{p p‚Ä≤}(P) D_{m_2 m^{\prime}}^{n^{\prime}}(-\gamma,-\beta,-\alpha)\quad p,p‚Ä≤=1,2
```

### Axisymmetric T-Matrix

### Mie T-Matrix

```
rotate(ùêì::MieTransitionMatrix{CT, N}, rot::Rotation{3})
```

- For a `MieTransitionMatrix`, the underlying Mie coefficients are copied and a new `MieTransitionMatrix` will be returned.
"""
function rotate(ùêì::AbstractTransitionMatrix{CT, N}, rot::Rotation{3}) where {CT, N}
    # Get the Euler angle in Z-Y-Z order.
    zyz = RotZYZ(rot)
    Œ±, Œ≤, Œ≥ = zyz.theta1, zyz.theta2, zyz.theta3

    # Calculate the wigner-d functions that will be used.
    d = OffsetArray(zeros(CT, 2N + 1, 2N + 1, N + 1), (-N):N, (-N):N, 0:N)
    for m in (-N):N
        for m‚Ä≤ in (-N):N
            s‚Çò·µ¢‚Çô = max(abs(m), abs(m‚Ä≤))
            wigner_d_recursion!(view(d, m, m‚Ä≤, s‚Çò·µ¢‚Çô:N), m, m‚Ä≤, N, Œ≤)
        end
    end

    # Calculate the coefficients used for wigner-D functions
    coeff = OffsetArray([cis(-(m * Œ± + m‚Ä≤ * Œ≥)) for m in (-N):N, m‚Ä≤ in (-N):N], (-N):N,
                        (-N):N)

    # Calculate the rotated T-Matrix
    ùêì‚Ä≤ = similar(ùêì)
    fill!(ùêì‚Ä≤, 0)

    # Enable multi-threading
    Threads.@threads for (n‚Ä≤, m‚Ä≤) in OrderDegreeIterator(N)
        for p in 1:2, p‚Ä≤ in 1:2
            for (n, m) in OrderDegreeIterator(N)
                for m‚ÇÇ in (-n‚Ä≤):n‚Ä≤, m‚ÇÅ in (-n):n
                    sign = iseven(m‚Ä≤ + m‚ÇÇ) ? 1 : -1
                    ùêì‚Ä≤[m, n, m‚Ä≤, n‚Ä≤, p, p‚Ä≤] += coeff[m, m‚ÇÅ] * d[m, m‚ÇÅ, n] *
                                               conj(coeff[m‚Ä≤, m‚ÇÇ]) * d[m‚ÇÇ, m‚Ä≤, n‚Ä≤] * sign *
                                               ùêì[m‚ÇÅ, n, m‚ÇÇ, n‚Ä≤, p, p‚Ä≤]
                end
            end
        end
    end

    TransitionMatrix{CT, N, typeof(ùêì‚Ä≤)}(ùêì‚Ä≤)
end

@doc raw"""
Calculate the amplitude matrix of the given T-Matrix `ùêì` at the given incidence and scattering angles. `k‚ÇÅ` is the wavenumber of the incident wave in the host medium, which should be calculated by `k‚ÇÅ = 2œÄ * m‚Çï / Œª`, where `m‚Çï` is the refractive index of the host medium and `Œª` is the wavelength of the incident wave. The default value is `k‚ÇÅ = 1.0`.

### General T-Matrix

```
amplitude_matrix(ùêì::AbstractTransitionMatrix{CT, N}, œë·µ¢, œÜ·µ¢, œë‚Çõ, œÜ‚Çõ, k‚ÇÅ=1.0)
```

For a general T-Matrix, Eq. (5.11) -- Eq. (5.17) in Mishchenko et al. (2002) is used as a fallback.

```math
\begin{array}{l}
S_{11}\left(\hat{\mathbf{n}}^{\text {sca }}, \hat{\mathbf{n}}^{\text {inc }}\right)=\frac{1}{k_1} \sum_{n=1}^{\infty} \sum_{n^{\prime}=1}^{\infty} \sum_{m=-n}^n \sum_{m^{\prime}=-n^{\prime}}^{n^{\prime}} \alpha_{m n m^{\prime} n^{\prime}}\left[T_{m n m^{\prime} n^{\prime}}^{11} \pi_{m n}\left(\vartheta^{\text {sca }}\right) \pi_{m^{\prime} n^{\prime}}\left(\vartheta^{\text {inc }}\right)\right. \\
+T_{m n m^{\prime} n^{\prime}}^{21} \tau_{m n}\left(\vartheta^{\text {sca }}\right) \pi_{m^{\prime} n^{\prime}}\left(\vartheta^{\mathrm{inc}}\right)+T_{m n m^{\prime} n^{\prime}}^{12} \pi_{m n}\left(\vartheta^{\text {sca }}\right) \tau_{m^{\prime} n^{\prime}}\left(\vartheta^{\mathrm{inc}}\right) \\
\left.+T_{m n m^{\prime} n^2}^{22} \tau_{m n}\left(\vartheta^{\text {sca }}\right) \tau_{m^{\prime} n^{\prime}}\left(\vartheta^{\text {inc }}\right)\right] \exp \left[\mathrm{i}\left(m \varphi^{\text {sca }}-m^{\prime} \varphi^{\text {inc }}\right)\right] \text {, } \\
S_{12}\left(\hat{\mathbf{n}}^{\mathrm{sca}}, \hat{\mathbf{n}}^{\mathrm{inc}}\right)=\frac{1}{\mathrm{i} k_1} \sum_{n=1}^{\infty} \sum_{n^{\prime}=1}^{\infty} \sum_{m=-n}^n \sum_{m^{\prime}=-n^{\prime}}^{n^{\prime}} \alpha_{m n m^{\prime} n^{\prime}}\left[T_{m n m^{\prime} n^{\prime}}^{11} \pi_{m n}\left(\vartheta^{\mathrm{sca}}\right) \tau_{m^{\prime} n^{\prime}}\left(\vartheta^{\mathrm{inc}}\right)\right. \\
+T_{m n m^{\prime} n^{\prime}}^{21} \tau_{m n}\left(\vartheta^{\text {sca }}\right) \tau_{m^{\prime} n^{\prime}}\left(\vartheta^{\mathrm{inc}}\right)+T_{m n m^{\prime} n^{\prime}}^{12} \pi_{m n}\left(\vartheta^{\text {sca }}\right) \pi_{m^{\prime} n^{\prime}}\left(\vartheta^{\text {inc }}\right) \\
\left.+T_{m n m^{\prime} n^{\prime}}^{22} \tau_{m n}\left(\vartheta^{\text {sca }}\right) \pi_{m^{\prime} n^{\prime}}\left(\vartheta^{\text {inc }}\right)\right] \exp \left[\mathrm{i}\left(m \varphi^{\text {sca }}-m^{\prime} \varphi^{\text {inc }}\right)\right] \text {, } \\
S_{21}\left(\hat{\mathbf{n}}^{\mathrm{sca}}, \hat{\mathbf{n}}^{\mathrm{inc}}\right)=\frac{\mathrm{i}}{k_1} \sum_{n=1}^{\infty} \sum_{n^{\prime}=1}^{\infty} \sum_{m=-n}^n \sum_{m^{\prime}=-n^{\prime}}^{n^{\prime}} \alpha_{m n m^{\prime} n^{\prime}}\left[T_{m n m^{\prime} n^{\prime}}^{11} \tau_{m n}\left(\vartheta^{\mathrm{sca}}\right) \pi_{m^{\prime} n^{\prime}}\left(\vartheta^{\mathrm{inc}}\right)\right. \\
+T_{m n m^{\prime} n^{\prime}}^{21} \pi_{m n}\left(\vartheta^{\text {sca }}\right) \pi_{m^{\prime} n^{\prime}}\left(\vartheta^{\mathrm{inc}}\right)+T_{m n m^{\prime} n^{\prime}}^{12} \tau_{m n}\left(\vartheta^{\text {sca }}\right) \tau_{m^{\prime} n^{\prime}}\left(\vartheta^{\text {inc }}\right) \\
\left.+T_{m n m^{\prime} n^{\prime}}^{22} \pi_{m n}\left(\vartheta^{\text {sca }}\right) \tau_{m^{\prime} n^{\prime}}\left(\vartheta^{\text {inc }}\right)\right] \exp \left[\mathrm{i}\left(m \varphi^{\text {sca }}-m^{\prime} \varphi^{\text {inc }}\right)\right] \text {, } \\
S_{22}\left(\hat{\mathbf{n}}^{\text {sca }}, \hat{\mathbf{n}}^{\mathrm{inc}}\right)=\frac{1}{k_1} \sum_{n=1}^{\infty} \sum_{n^{\prime}=1}^{\infty} \sum_{m=-n}^n \sum_{m^{\prime}=-n^{\prime}}^{n^{\prime}} \alpha_{m n m^{\prime} n^{\prime}}\left[T_{m n n^{\prime} n^{\prime}}^{11} \tau_{m n}\left(\vartheta^{\text {sca }}\right) \tau_{m^{\prime} n^{\prime}}\left(\vartheta^{\text {inc }}\right)\right. \\
+T_{m n m^{\prime} n^{\prime}}^{21} \pi_{m n}\left(\vartheta^{\text {sca }}\right) \tau_{m^{\prime} n^{\prime}}\left(\vartheta^{\text {inc }}\right)+T_{m n m^{\prime} n^{12}}^{12} \tau_{m n}\left(\vartheta^{\text {sca }}\right) \pi_{m^{\prime} n^{\prime}}\left(\vartheta^{\text {inc }}\right) \\
\left.+T_{m n m^{\prime} n^{\prime}}^{22} \pi_{m n}\left(\vartheta^{\text {sca }}\right) \pi_{m^{\prime} n^{\prime}}\left(\vartheta^{\text {inc }}\right)\right] \exp \left[\mathrm{i}\left(m \varphi^{\text {sca }}-m^{\prime} \varphi^{\text {inc }}\right)\right], \\
\end{array}
```

Where

```math
\begin{array}{l}
\alpha_{m n m^{\prime} n^{\prime}}=\mathrm{i}^{n^{\prime}-n-1}(-1)^{m+m^{\prime}}\left[\frac{(2 n+1)\left(2 n^{\prime}+1\right)}{n(n+1) n^{\prime}\left(n^{\prime}+1\right)}\right]^{1 / 2}, \\
\pi_{m n}(\vartheta)=\frac{m d_{0 m}^n(\vartheta)}{\sin \vartheta}, \quad \pi_{-m n}(\vartheta)=(-1)^{m+1} \pi_{m n}(\vartheta), \\
\tau_{m n}(\vartheta)=\frac{\mathrm{d} d_{0 m}^n(\vartheta)}{\mathrm{d} \vartheta}, \quad \tau_{-m n}(\vartheta)=(-1)^m \tau_{m n}(\vartheta)
\end{array}
```

### Axisymmetric T-Matrix

### Mie T-Matrix

"""
function amplitude_matrix(ùêì::AbstractTransitionMatrix{CT, N}, œë·µ¢, œÜ·µ¢, œë‚Çõ, œÜ‚Çõ,
                          k‚ÇÅ = 1.0) where {CT, N}
    T = real(CT)
    ùêí‚ÇÅ‚ÇÅ, ùêí‚ÇÅ‚ÇÇ, ùêí‚ÇÇ‚ÇÅ, ùêí‚ÇÇ‚ÇÇ = zero(CT), zero(CT), zero(CT), zero(CT)

    œÄ·µ¢ = OffsetArray(zeros(T, 2N + 1, N + 1), (-N):N, 0:N)
    œÑ·µ¢ = OffsetArray(zeros(T, 2N + 1, N + 1), (-N):N, 0:N)
    œÄ‚Çõ = OffsetArray(zeros(T, 2N + 1, N + 1), (-N):N, 0:N)
    œÑ‚Çõ = OffsetArray(zeros(T, 2N + 1, N + 1), (-N):N, 0:N)
    for m in 0:N
        wigner_d_recursion!(view(œÄ·µ¢, m, m:N),
                            0, m, N, œë·µ¢;
                            deriv = view(œÑ·µ¢, m, m:N))

        wigner_d_recursion!(view(œÄ‚Çõ, m, m:N),
                            0, m, N, œë‚Çõ;
                            deriv = view(œÑ‚Çõ, m, m:N))
    end

    for n in 1:N
        for m in 0:n
            œÄ·µ¢[m, n] = pi_func(T, m, n, œë·µ¢; d = œÄ·µ¢[m, n])
            œÄ‚Çõ[m, n] = pi_func(T, m, n, œë‚Çõ; d = œÄ‚Çõ[m, n])
            if m > 0
                œÄ·µ¢[-m, n] = (-1)^((m + 1) & 1) * œÄ·µ¢[m, n]
                œÄ‚Çõ[-m, n] = (-1)^((m + 1) & 1) * œÄ‚Çõ[m, n]
                œÑ·µ¢[-m, n] = (-1)^(m & 1) * œÑ·µ¢[m, n]
                œÑ‚Çõ[-m, n] = (-1)^(m & 1) * œÑ‚Çõ[m, n]
            end
        end
    end

    for n‚Ä≤ in 1:N, n in 1:N
        Œ±‚Çô = 1.0im^((n‚Ä≤ - n - 1) & 3) *
             ‚àö(T(2n + 1) * (2n‚Ä≤ + 1) / (n * (n + 1) * n‚Ä≤ * (n‚Ä≤ + 1)))
        for m‚Ä≤ in (-n‚Ä≤):n‚Ä≤
            for m in (-n):n
                Œ± = (-1.0)^((m + m‚Ä≤) & 1) * Œ±‚Çô
                expiœÜ = cis(m * œÜ‚Çõ - m‚Ä≤ * œÜ·µ¢)
                ùêí‚ÇÅ‚ÇÅ += Œ± *
                       (ùêì[m, n, m‚Ä≤, n‚Ä≤, 1, 1] * œÄ‚Çõ[m, n] * œÄ·µ¢[m‚Ä≤, n‚Ä≤] +
                        ùêì[m, n, m‚Ä≤, n‚Ä≤, 1, 2] * œÄ‚Çõ[m, n] * œÑ·µ¢[m‚Ä≤, n‚Ä≤] +
                        ùêì[m, n, m‚Ä≤, n‚Ä≤, 2, 1] * œÑ‚Çõ[m, n] * œÄ·µ¢[m‚Ä≤, n‚Ä≤] +
                        ùêì[m, n, m‚Ä≤, n‚Ä≤, 2, 2] * œÑ‚Çõ[m, n] * œÑ·µ¢[m‚Ä≤, n‚Ä≤]) * expiœÜ

                ùêí‚ÇÅ‚ÇÇ += Œ± *
                       (ùêì[m, n, m‚Ä≤, n‚Ä≤, 1, 1] * œÄ‚Çõ[m, n] * œÑ·µ¢[m‚Ä≤, n‚Ä≤] +
                        ùêì[m, n, m‚Ä≤, n‚Ä≤, 1, 2] * œÄ‚Çõ[m, n] * œÄ·µ¢[m‚Ä≤, n‚Ä≤] +
                        ùêì[m, n, m‚Ä≤, n‚Ä≤, 2, 1] * œÑ‚Çõ[m, n] * œÑ·µ¢[m‚Ä≤, n‚Ä≤] +
                        ùêì[m, n, m‚Ä≤, n‚Ä≤, 2, 2] * œÑ‚Çõ[m, n] * œÄ·µ¢[m‚Ä≤, n‚Ä≤]) * expiœÜ

                ùêí‚ÇÇ‚ÇÅ += Œ± *
                       (ùêì[m, n, m‚Ä≤, n‚Ä≤, 1, 1] * œÑ‚Çõ[m, n] * œÄ·µ¢[m‚Ä≤, n‚Ä≤] +
                        ùêì[m, n, m‚Ä≤, n‚Ä≤, 1, 2] * œÑ‚Çõ[m, n] * œÑ·µ¢[m‚Ä≤, n‚Ä≤] +
                        ùêì[m, n, m‚Ä≤, n‚Ä≤, 2, 1] * œÄ‚Çõ[m, n] * œÄ·µ¢[m‚Ä≤, n‚Ä≤] +
                        ùêì[m, n, m‚Ä≤, n‚Ä≤, 2, 2] * œÄ‚Çõ[m, n] * œÑ·µ¢[m‚Ä≤, n‚Ä≤]) * expiœÜ

                ùêí‚ÇÇ‚ÇÇ += Œ± *
                       (ùêì[m, n, m‚Ä≤, n‚Ä≤, 1, 1] * œÑ‚Çõ[m, n] * œÑ·µ¢[m‚Ä≤, n‚Ä≤] +
                        ùêì[m, n, m‚Ä≤, n‚Ä≤, 1, 2] * œÑ‚Çõ[m, n] * œÄ·µ¢[m‚Ä≤, n‚Ä≤] +
                        ùêì[m, n, m‚Ä≤, n‚Ä≤, 2, 1] * œÄ‚Çõ[m, n] * œÑ·µ¢[m‚Ä≤, n‚Ä≤] +
                        ùêì[m, n, m‚Ä≤, n‚Ä≤, 2, 2] * œÄ‚Çõ[m, n] * œÄ·µ¢[m‚Ä≤, n‚Ä≤]) * expiœÜ
            end
        end
    end

    return (@SMatrix [ùêí‚ÇÅ‚ÇÅ ùêí‚ÇÅ‚ÇÇ/1im; ùêí‚ÇÇ‚ÇÅ*1im ùêí‚ÇÇ‚ÇÇ]) ./ k‚ÇÅ
end
